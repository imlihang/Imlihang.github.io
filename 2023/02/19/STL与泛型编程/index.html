<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="C++ Standard Library vs. Standard Template LibraryC++ 标准库，编译器提供了 标准库所有的头文件， STL  标准模板库，包含 6 大组件 C++ 标准库 &gt;  STL 标准模板库  不同编译器的 STL 使用方法几乎完全一样 STL 六大部件 容器用来存储数据 分配器用来为容器分配内存 算法通过迭代器访问数据  count_if 范围内满">
<meta property="og:type" content="article">
<meta property="og:title" content="STL与泛型编程">
<meta property="og:url" content="http://example.com/2023/02/19/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="咱老李">
<meta property="og:description" content="C++ Standard Library vs. Standard Template LibraryC++ 标准库，编译器提供了 标准库所有的头文件， STL  标准模板库，包含 6 大组件 C++ 标准库 &gt;  STL 标准模板库  不同编译器的 STL 使用方法几乎完全一样 STL 六大部件 容器用来存储数据 分配器用来为容器分配内存 算法通过迭代器访问数据  count_if 范围内满">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230219212258600.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230220192433676.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230220193157143.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230220194444295.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230220194755799.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230220195417690.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230220195830686.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230220210523310.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230220210914454.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230222192445663.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230222202913719.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230222203502491.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230224204342960.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230224205808789.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230224210013888.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230224210753508.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230224211454228.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230224211917680.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230224211924952.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225093315502.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225093529985.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225095655839.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225202838006.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225202844089.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225202910673.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225203007756.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225203118319.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225203125456.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225203130877.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225203536271.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226184403583.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226184412843.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226184604371.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226184905547.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226184909839.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226184914388.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226184920272.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226185932016.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226185937516.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226190016680.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226190903904.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226191520720.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226191616757.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227193922968.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227194105883.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227194131171.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227195138862.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227195834435.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227200115500.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227200121224.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227200948665.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227202114481.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227202504789.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227202516406.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230302195247105.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319153556627.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319153605924.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319154156980.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319154205944.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319154223340.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319154827577.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319154833452.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319155516876.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319160123279.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319160917208.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319162548867.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319163140362.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319163536101.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319165021365.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319170328799.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319172009714.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319172258111.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319172454828.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319172508238.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230325162650661.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230325162738147.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230325162905118.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230325163642617.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230325164005935.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230325165124415.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230325165134732.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326163959771.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326164004026.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326164019896.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326165554344.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326165731166.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326170215913.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326171156888.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326172003437.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326173808204.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326173916410.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326174651722.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326175156047.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402120211117.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402120303305.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402120454564.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402120515796.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402120828413.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402120845318.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402121620880.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402121058506.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402123625203.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402124843213.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402124810798.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402140424149.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402140428651.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402140436552.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402140443572.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402141230280.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402141748193.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402142329093.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402143034722.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402151114574.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402151500423.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402152434599.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402152941186.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402152947075.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402153736280.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402161709425.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402162757100.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402163841988.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402165129090.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402170657429.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402171122637.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402172317190.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402175053840.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402175100544.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402175105449.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402175117464.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402183243161.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402183248456.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230729163709837.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230729164416622.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230729165646012.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230729171120270.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230729180517956.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230729181031248.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230729181630375.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230809203604180.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230809204853613.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230810193758187.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230810193826962.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230810194035071.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230810195535783.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230810200221351.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230812194510444.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230812200309943.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230812201008512.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230812201441966.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230812203355789.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230812203327459.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230813153928015.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230813154246025.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230813213707788.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230813214215660.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230813214619164.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230813215244076.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230813220502935.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230813221211204.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230815201809620.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230815210124354.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230815213626345.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230816203759517.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230816204205063.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230816210951499.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230816210957987.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230816211005014.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230828201208327.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230828202341781.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230906203848509.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230906203909937.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230906204625697.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230906204645119.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230906205013669.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230906205123247.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230906205644144.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230914213542645.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230914214525087.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916090826613.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916090847529.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916091151682.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916091423619.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916091453065.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916092448488.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916092455357.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916092501924.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916093623966.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916093634792.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916093644704.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916173209871.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916173823329.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916174121739.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916174540684.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916174841180.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917093700847.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917093708546.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917093715366.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917093722334.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917093729426.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917093757490.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917093803249.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917094843213.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917100225231.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917100310510.png">
<meta property="og:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917100925551.png">
<meta property="article:published_time" content="2023-02-19T14:02:31.000Z">
<meta property="article:modified_time" content="2023-09-17T06:57:36.607Z">
<meta property="article:author" content="Henry">
<meta property="article:tag" content="C">
<meta property="article:tag" content="侯捷">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230219212258600.png">

<link rel="canonical" href="http://example.com/2023/02/19/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>STL与泛型编程 | 咱老李</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">咱老李</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/19/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Henry">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咱老李">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          STL与泛型编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-19 22:02:31" itemprop="dateCreated datePublished" datetime="2023-02-19T22:02:31+08:00">2023-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-17 14:57:36" itemprop="dateModified" datetime="2023-09-17T14:57:36+08:00">2023-09-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/STL%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">STL与泛型编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="C-Standard-Library-vs-Standard-Template-Library"><a href="#C-Standard-Library-vs-Standard-Template-Library" class="headerlink" title="C++ Standard Library vs. Standard Template Library"></a>C++ Standard Library vs. Standard Template Library</h1><p>C++ 标准库，编译器提供了 标准库所有的头文件，</p>
<p>STL  标准模板库，包含 6 大组件</p>
<p>C++ 标准库 &gt;  STL 标准模板库</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230219212258600.png" alt="image-20230219212258600"></p>
<p>不同编译器的 STL 使用方法几乎完全一样</p>
<h1 id="STL-六大部件"><a href="#STL-六大部件" class="headerlink" title="STL 六大部件"></a>STL 六大部件</h1><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230220192433676.png" alt="image-20230220192433676"></p>
<p><strong>容器</strong>用来存储数据</p>
<p><strong>分配器</strong>用来为<strong>容器</strong>分配内存</p>
<p><strong>算法</strong>通过<strong>迭代器</strong>访问数据</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230220193157143.png" alt="image-20230220193157143"></p>
<p>count_if 范围内满足某个条件的元素有多少个</p>
<h1 id="复杂度-Complexity-Big-oh"><a href="#复杂度-Complexity-Big-oh" class="headerlink" title="复杂度 Complexity, Big-oh"></a>复杂度 Complexity, Big-oh</h1><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230220194444295.png" alt="image-20230220194444295"></p>
<h1 id="前闭后开-区间"><a href="#前闭后开-区间" class="headerlink" title="前闭后开 区间"></a>前闭后开 区间</h1><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230220194755799.png" alt="image-20230220194755799"></p>
<p>容器内 数据的内存不一定是连续的  可能是链表或者树的形式存储。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230220195417690.png" alt="image-20230220195417690"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230220195830686.png" alt="image-20230220195830686"></p>
<h1 id="容器-—-结构与分类"><a href="#容器-—-结构与分类" class="headerlink" title="容器 — 结构与分类"></a>容器 — 结构与分类</h1><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230220210523310.png" alt="image-20230220210523310"></p>
<h2 id="Set-与-Map-区别"><a href="#Set-与-Map-区别" class="headerlink" title="Set 与 Map 区别"></a>Set 与 Map 区别</h2><p>Map 有 key,value   Set没有这个分别</p>
<p>HashTable 数组加链表实现，链表很长的话影响效率，可能会重新打乱再排。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230220210914454.png" alt="image-20230220210914454"></p>
<h2 id="使用容器-array"><a href="#使用容器-array" class="headerlink" title="使用容器 array"></a>使用容器 array</h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230222192445663.png" alt="image-20230222192445663"></p>
<h2 id="使用vector"><a href="#使用vector" class="headerlink" title="使用vector"></a>使用vector</h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230222202913719.png" alt="image-20230222202913719"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230222203502491.png" alt="image-20230222203502491"></p>
<h2 id="使用-list"><a href="#使用-list" class="headerlink" title="使用 list"></a>使用 list</h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230224204342960.png" alt="image-20230224204342960"></p>
<p>list 提供了自己的 sort 函数，与 STL 算法中 sort 不同。</p>
<p>在 sort 的时候要调用自己特有的 sort 函数。</p>
<h2 id="使用-forward-list"><a href="#使用-forward-list" class="headerlink" title="使用 forward_list"></a>使用 forward_list</h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230224205808789.png" alt="image-20230224205808789"></p>
<h2 id="使用-slist"><a href="#使用-slist" class="headerlink" title="使用 slist"></a>使用 slist</h2><p>与 forward_list 一样  但是 forward_list 是 C++ 标准库中</p>
<p>slist 是 gnu 编译器早期的版本</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230224210013888.png" alt="image-20230224210013888"></p>
<h2 id="使用-deque"><a href="#使用-deque" class="headerlink" title="使用 deque"></a>使用 deque</h2><p>deque有很多段，每个段内 内存都是连续的，是分段连续的。</p>
<p>当迭代器到段落边的时候，会进行判断。</p>
<p>当push段落满的时候，会新创建一个段。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230224210753508.png" alt="image-20230224210753508"></p>
<p>使用全局的 sort 排序</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230224211454228.png" alt="image-20230224211454228"></p>
<h2 id="使用-stack"><a href="#使用-stack" class="headerlink" title="使用 stack"></a>使用 stack</h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230224211917680.png" alt="image-20230224211917680"></p>
<h2 id="使用queue"><a href="#使用queue" class="headerlink" title="使用queue"></a>使用queue</h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230224211924952.png" alt="image-20230224211924952"></p>
<p>stack 和 queue 底层都是借助 deque 实现的。所以叫做 容器的  adapter</p>
<h2 id="使用multiset"><a href="#使用multiset" class="headerlink" title="使用multiset"></a>使用multiset</h2><p>集合Set  没有重复元素</p>
<p>multiset 可以有重复元素</p>
<p>STL find 没有 容器自带的快</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225093315502.png" alt="image-20230225093315502"></p>
<h2 id="使用容器-multimap"><a href="#使用容器-multimap" class="headerlink" title="使用容器 multimap"></a>使用容器 multimap</h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225093529985.png" alt="image-20230225093529985"></p>
<h2 id="使用容器-unordered-multiset"><a href="#使用容器-unordered-multiset" class="headerlink" title="使用容器 unordered_multiset"></a>使用容器 unordered_multiset</h2><p>使用 hashTable 实现，hashTable 是在一定经验值情况下发明的数据结构</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225095655839.png" alt="image-20230225095655839"></p>
<p>数据排布准则</p>
<p>如果元素个数大于 bucket_count 就扩充 bucket_count  然后打乱重排</p>
<p>所以 bucket_count  一定大于元素个数                                               </p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225202838006.png" alt="image-20230225202838006"></p>
<h2 id="使用容器-unordered-multiset-1"><a href="#使用容器-unordered-multiset-1" class="headerlink" title="使用容器 unordered_multiset"></a>使用容器 unordered_multiset<img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225202844089.png" alt="image-20230225202844089"></h2><h2 id="使用容器-set"><a href="#使用容器-set" class="headerlink" title="使用容器 set"></a>使用容器 set</h2><p>不允许重复元素存在</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225202910673.png" alt="image-20230225202910673"></p>
<h2 id="使用容器-map"><a href="#使用容器-map" class="headerlink" title="使用容器 map"></a>使用容器 map</h2><p>在map 中可以用 c[i] &#x3D; string(buf)，不一定要用自带的 Insert 内部会组成一个 pair</p>
<p>因为 map 中的元素的是唯一的</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225203007756.png" alt="image-20230225203007756"></h4><h2 id="使用容器-unordered-set"><a href="#使用容器-unordered-set" class="headerlink" title="使用容器 unordered_set"></a>使用容器 unordered_set<img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225203118319.png" alt="image-20230225203118319"></h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225203125456.png" alt="image-20230225203125456"></p>
<h2 id="使用容器-unordered-map"><a href="#使用容器-unordered-map" class="headerlink" title="使用容器 unordered_map"></a>使用容器 unordered_map</h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225203130877.png" alt="image-20230225203130877"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230225203536271.png" alt="image-20230225203536271"></p>
<p>容器 hash_xx  是 GNU 内实现的，</p>
<p>在 C++ 11 标准中要注意头文件的位置在哪</p>
<h1 id="使用分配器"><a href="#使用分配器" class="headerlink" title="使用分配器"></a>使用分配器</h1><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226184403583.png" alt="image-20230226184403583"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226184412843.png" alt="image-20230226184412843"></p>
<p>分配器一般搭配容器使用，如果只是普通的申请内存用 malloc&#x2F;new 即可，单纯的使用分配器申请内存会比较麻烦，deallocate 要传入申请的大小。</p>
<p>分配器是一个类，内部最终也其实是调用 malloc&#x2F;new 这种方式。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226184604371.png" alt="image-20230226184604371"></p>
<h1 id="标准库版本"><a href="#标准库版本" class="headerlink" title="标准库版本"></a>标准库版本</h1><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226184905547.png" alt="image-20230226184905547"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226184909839.png" alt="image-20230226184909839"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226184914388.png" alt="image-20230226184914388"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226184920272.png" alt="image-20230226184920272"></p>
<h1 id="OOP-vs-GP"><a href="#OOP-vs-GP" class="headerlink" title="OOP vs. GP"></a>OOP vs. GP</h1><p>加减除这种操作只有 <strong>RandomAccessIterator</strong> 可以操作</p>
<p><strong>RandomAccessIterator</strong> 指的是像数组这样可以  pArr + 0， pArr + 3， 跳跃访问数组中的元素。</p>
<p>list 是一个一个节点串起来的。</p>
<p>容器中有 sort 实现必须用 sort 去排序。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226185932016.png" alt="image-20230226185932016"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226185937516.png" alt="image-20230226185937516"></p>
<p>使用模板将容器和算法分开，容器和算法可以互不干扰，两者通过迭代器沟通。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226190016680.png" alt="image-20230226190016680"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226190903904.png" alt="image-20230226190903904"></p>
<h1 id="操作符重载-Operator-Overloading"><a href="#操作符重载-Operator-Overloading" class="headerlink" title="操作符重载 Operator Overloading"></a>操作符重载 Operator Overloading</h1><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226191520720.png" alt="image-20230226191520720"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230226191616757.png" alt="image-20230226191616757"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227193922968.png" alt="image-20230227193922968"></p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="Class-Templates-类模板"><a href="#Class-Templates-类模板" class="headerlink" title="Class Templates 类模板"></a>Class Templates 类模板</h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227194105883.png" alt="image-20230227194105883"></p>
<h2 id="Function-Templates-函数模板"><a href="#Function-Templates-函数模板" class="headerlink" title="Function Templates 函数模板"></a>Function Templates 函数模板</h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227194131171.png" alt="image-20230227194131171"></p>
<h2 id="Member-Templates-成员模板"><a href="#Member-Templates-成员模板" class="headerlink" title="Member Templates,成员模板"></a>Member Templates,成员模板</h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227195138862.png" alt="image-20230227195138862"></p>
<h2 id="Specialization-特化"><a href="#Specialization-特化" class="headerlink" title="Specialization 特化"></a>Specialization 特化</h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227195834435.png" alt="image-20230227195834435"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227200115500.png" alt="image-20230227200115500"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227200121224.png" alt="image-20230227200121224"></p>
<h2 id="Partial-Specialization-偏特化"><a href="#Partial-Specialization-偏特化" class="headerlink" title="Partial Specialization 偏特化"></a>Partial Specialization 偏特化</h2><p>参数的偏</p>
<p>范围的偏 如果是指针类型，类型范围的偏</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227200948665.png" alt="image-20230227200948665"></p>
<h1 id="分配器-allocators"><a href="#分配器-allocators" class="headerlink" title="分配器 allocators"></a>分配器 allocators</h1><p>分配器最后都会调到 malloc</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227202114481.png" alt="image-20230227202114481"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227202504789.png" alt="image-20230227202504789"></p>
<p>VC的分配器没有特殊设计</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230227202516406.png" alt="image-20230227202516406"></p>
<p>G2.9 </p>
<p>​	较小对象每次 malloc 内存会有较多的额外开销(存放 cookie)。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230302195247105.png" alt="image-20230302195247105"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319153556627.png" alt="image-20230319153556627"></p>
<p>通过链表构建内存池，事先malloc一大块内存，然后进行内存管理，从而减小容器中每个元素内存额外开销。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319153605924.png" alt="image-20230319153605924"></p>
<p>但是 G4.9 默认的分配器没有沿用这种比较好的写法。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319154156980.png" alt="image-20230319154156980"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319154205944.png" alt="image-20230319154205944"></p>
<p>G4.9 __pool_alloc 就是 G2.9 的 alloc</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319154223340.png" alt="image-20230319154223340"></p>
<h1 id="容器结构与分类"><a href="#容器结构与分类" class="headerlink" title="容器结构与分类"></a>容器结构与分类</h1><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319154827577.png" alt="image-20230319154827577"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319154833452.png" alt="image-20230319154833452"></p>
<h1 id="深度探索list"><a href="#深度探索list" class="headerlink" title="深度探索list"></a>深度探索list</h1><p>STL 里边会有很多自己的 typedef </p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319155516876.png" alt="image-20230319155516876"></p>
<p>list 是非连续空间，所以说 list  iterator 不能使用指针实现。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319160123279.png" alt="image-20230319160123279"></p>
<p>self operator++() &#x2F;&#x2F;不带参数 后置++的重载   i++</p>
<p>self operator++(int) &#x2F;&#x2F;带参数 前置++的重载  ++i</p>
<p>在 self tmp &#x3D; *this; 时，因为先遇到了 &#x3D; ，所以编译器会先调用赋值构造函数。</p>
<p>C++ 不允许后置++连续两次，所以迭代器的操作应该有这样的实现。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319160917208.png" alt="image-20230319160917208"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319162548867.png" alt="image-20230319162548867"></p>
<p>老版本中的 list iterator 的 typedef 较为复杂，要传三个参数 T,T&amp;,T* 实际上只传一个 T 就可以了。</p>
<p>G4.9 的 typedef 更容易理解。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319163140362.png" alt="image-20230319163140362"></p>
<p>G4.9代码更复杂</p>
<p>容器的最后要加一个空白，让最后一个元素指向空白，满足前闭后开原则。</p>
<p>G4.9 sizeof(list) &#x3D; 两个指针大小。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319163536101.png" alt="image-20230319163536101"></p>
<h1 id="迭代器的设计原则-iterator"><a href="#迭代器的设计原则-iterator" class="headerlink" title="迭代器的设计原则 iterator"></a>迭代器的设计原则 iterator</h1><p>iterator_category 迭代器的分类，是连续存储还是非连续存储</p>
<p>difference_type    两个迭代器之间的距离 用什么类型存储，用不会超范围的类型</p>
<p>value_type    数据的类型</p>
<p>reference&#x2F;pointer 类型，还未在 C++ 标准库中使用</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319165021365.png" alt="image-20230319165021365"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319170328799.png" alt="image-20230319170328799"></p>
<p>指针也是一种迭代器，那么如果传给算法是一个指针，指针没有这五个typedef, 就需要 iterator traits</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319172009714.png" alt="image-20230319172009714"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319172258111.png" alt="image-20230319172258111"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319172454828.png" alt="image-20230319172454828"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230319172508238.png" alt="image-20230319172508238"></p>
<h1 id="容器-vector"><a href="#容器-vector" class="headerlink" title="容器 vector"></a>容器 vector</h1><p>vector其实是动态增长的数组</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230325162650661.png" alt="image-20230325162650661"></p>
<p>push_back 内存不够时，会以2倍增长的方式扩充内存</p>
<p>insert_aux 也会被 insert 调用，所以 insert_aux 仍有空间容量的判断</p>
<p>而且在 insert 的时候，要拷贝插入节点前的内容，插入元素后也要拷贝插入节点后的内容</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230325162738147.png" alt="image-20230325162738147"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230325162905118.png" alt="image-20230325162905118"></p>
<h2 id="vector-iterator"><a href="#vector-iterator" class="headerlink" title="vector iterator"></a>vector iterator</h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230325163642617.png" alt="image-20230325163642617"></p>
<p>G4.9 的实现稍微复杂</p>
<p>houjie 认为这里 public 不理想 应该是 private 继承</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230325164005935.png" alt="image-20230325164005935"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230325165124415.png" alt="image-20230325165124415"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230325165134732.png" alt="image-20230325165134732"></p>
<h1 id="容器-array"><a href="#容器-array" class="headerlink" title="容器 array"></a>容器 array</h1><p>array 要包装一下变成容器 才能使用 STL 的相关内容</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326163959771.png" alt="image-20230326163959771"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326164004026.png" alt="image-20230326164004026"></p>
<h1 id="容器-forward-list"><a href="#容器-forward-list" class="headerlink" title="容器 forward_list"></a>容器 forward_list</h1><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326164019896.png" alt="image-20230326164019896"></p>
<h1 id="容器-deque"><a href="#容器-deque" class="headerlink" title="容器 deque"></a>容器 deque</h1><p>deque 容器实现 会创建多个缓冲区(node)，每个 node 里边的数据连续。</p>
<p>通过 map 来管理多个 node，当向前或者向后插入内存不够的时候，会再创建新的 node，然后放到 map 中。</p>
<p>iterator 中 </p>
<p>cur 表示当前所指向的数据</p>
<p>first end 代码该 node 的头跟尾</p>
<p>node 代表在 map 中的位置</p>
<p>容器都有 start finish 两个迭代器表示头跟尾</p>
<p>G2.9 允许指定缓冲区的大小</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326165554344.png" alt="image-20230326165554344"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326165731166.png" alt="image-20230326165731166">deque迭代器是 random_access_iterator</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326170215913.png" alt="image-20230326170215913"></p>
<h2 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326171156888.png" alt="image-20230326171156888"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326172003437.png" alt="image-20230326172003437"></p>
<h2 id="deque模拟连续空间"><a href="#deque模拟连续空间" class="headerlink" title="deque模拟连续空间"></a>deque模拟连续空间</h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326173808204.png" alt="image-20230326173808204"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326173916410.png" alt="image-20230326173916410">一般都会使用后置++ 调用前置 ++ 的实现</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326174651722.png" alt="image-20230326174651722"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230326175156047.png" alt="image-20230326175156047"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402120211117.png" alt="image-20230402120211117"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402120303305.png" alt="image-20230402120303305"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402120454564.png" alt="image-20230402120454564"></p>
<p>map 扩充，如 8 扩充到16个，会 copy 到16个的中间</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402120515796.png" alt="image-20230402120515796"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402120828413.png" alt="image-20230402120828413"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402120845318.png" alt="image-20230402120845318"><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402121620880.png" alt="image-20230402121620880"></p>
<p>对于模板来说，编译器是不会做全面的检查，如只有你代码中有调用了 c.pop() 编译器才会报错</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402121058506.png" alt="image-20230402121058506"></p>
<h1 id="容器-rb-tree"><a href="#容器-rb-tree" class="headerlink" title="容器 rb_tree"></a>容器 rb_tree</h1><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402123625203.png" alt="image-20230402123625203"><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402124843213.png" alt="image-20230402124843213">rb_tree sizeof(re_tree)</p>
<p>node_count 是一个 unsigned int  4字节</p>
<p>header 是一个指针  4字节</p>
<p>key_compare 是一个仿函数，本来应该大小为零，但是编译器对于大小为零的 class, 大小统一设置为 1。</p>
<p>在 list 中会刻意放一个空的元素，来实现前闭后开区间。</p>
<p>在 rb_tree 里边也有类似的结构，就是 header，这会让红黑树方便实现很多。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402124810798.png" alt="image-20230402124810798"></p>
<p>class Key   						key的类型</p>
<p>class Value 					  Value 的类型</p>
<p>class KeyOfValue 			从value中提取出key的方式</p>
<p>class Compare      			key比较大小的方式</p>
<p>GNU C 实现了 identity 仿函数，指定取 data 的方式，就是 key 自己。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402140424149.png" alt="image-20230402140424149"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402140428651.png" alt="image-20230402140428651"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402140436552.png" alt="image-20230402140436552"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402140443572.png" alt="image-20230402140443572"></p>
<p>handle and body</p>
<p>委托的方式实现，将具体实现做一个实现类。</p>
<h1 id="容器-set-multiset"><a href="#容器-set-multiset" class="headerlink" title="容器 set,multiset"></a>容器 set,multiset</h1><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402141230280.png" alt="image-20230402141230280"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402141748193.png" alt="image-20230402141748193"></p>
<p>迭代器是 const_iterator 避免使用者修改 set 元素</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402142329093.png" alt="image-20230402142329093"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402143034722.png" alt="image-20230402143034722"></p>
<h1 id="容器-map-multimap"><a href="#容器-map-multimap" class="headerlink" title="容器 map,multimap"></a>容器 map,multimap</h1><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402151114574.png" alt="image-20230402151114574"></p>
<p>map 中把  key和data 组合成一个 pair 通过 const 关键字将 Key 加上 const ，防止 key被修改</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402151500423.png" alt="image-20230402151500423"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402152434599.png" alt="image-20230402152434599"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402152941186.png" alt="image-20230402152941186"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402152947075.png" alt="image-20230402152947075"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402153736280.png" alt="image-20230402153736280"></p>
<h1 id="容器-hashtable"><a href="#容器-hashtable" class="headerlink" title="容器 hashtable"></a>容器 hashtable</h1><p>假设一个 Obj 有 2^32次方的变化，那么每个 obj 可以映射为一个编号，这个编号 T 就是这个对象的 id</p>
<p>限制我们可能没有那么大空间，假设只有 M 大小，就用编号 T 对 M 取余数，就是对应的 id 。但是这样做就可能有多个 obj 重复id.</p>
<p>M &#x3D; 100 时，id1 &#x3D; 5，id2 &#x3D; 105 % 100 &#x3D; 5.</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402161709425.png" alt="image-20230402161709425"></p>
<p>为了解决这个冲突，就想了这个方法，数组加链表</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402162757100.png" alt="image-20230402162757100"></p>
<p>但是如果链表太长，会影响效率，需要把它打散。</p>
<p>什么长度是比较长，使用经验公式判断。就是如果元素个数比链表的个数多，就要打散。一般链表的个数是质数，是原链表个数 2 倍附近的质数。GNU 已经写好了质数列表，不用再运行时计算。</p>
<p>打散是比较花时间的，重新申请空间，然后拷贝。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402163841988.png" alt="image-20230402163841988"></p>
<p>HashFcn 指的是 Obj 如何通过函数变成一个编号。这个编号又叫 HashCode</p>
<p>ExtractKey 怎么从 value 取出 key</p>
<p>EqualKey  什么情况下 key 是相等的</p>
<p>当链表走到尽头的时候，迭代器需要有能力返回 buckets。所以迭代器里边有一个 hashtable* </p>
<p>  <img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402165129090.png" alt="image-20230402165129090"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402170657429.png" alt="image-20230402170657429"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402171122637.png" alt="image-20230402171122637"></p>
<p>余数运算</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402172317190.png" alt="image-20230402172317190"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402175053840.png" alt="image-20230402175053840"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402175100544.png" alt="image-20230402175100544"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402175105449.png" alt="image-20230402175105449"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402175117464.png" alt="image-20230402175117464"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402183243161.png" alt="image-20230402183243161"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230402183248456.png" alt="image-20230402183248456"></p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="算法是什么"><a href="#算法是什么" class="headerlink" title="算法是什么"></a>算法是什么</h2><p>算法是一个函数模板   算法是处理容器的   算法只能看到迭代器</p>
<p>算法通过迭代器来获取关于容器的信息</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230729163709837.png" alt="image-20230729163709837"></p>
<h2 id="迭代器的分类"><a href="#迭代器的分类" class="headerlink" title="迭代器的分类"></a>迭代器的分类</h2><p>random_access_iterator_tag   指的是可以随机跳跃存取的迭代器</p>
<p>bidirectional_tierator_tag    比如 List  红黑树(红黑树也可以双向的)  HashTabel 的迭代器  双向的</p>
<p>forward_iterator_tag   Forward_List</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230729164416622.png" alt="image-20230729164416622"></p>
<p>STL 迭代器的分类是做成了有继承关系的五个类，  而不是用枚举标号 1，2，3，4，5</p>
<p>​       使用类和类继承可以利用函数重载的方式做分支</p>
<p>只有 ostreamIter 是 output_iterator_tag</p>
<p>使用迭代器类型+() 直接创建一个临时对象</p>
<p>使用 iterator_traits 拿到迭代器的类型，从而打印容器迭代器类型</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230729165646012.png" alt="image-20230729165646012"></p>
<p>使用 c++ 的 typeid 也可以打印出函数名称   实际输出类型会加前后缀</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230729171120270.png" alt="image-20230729171120270"></p>
<p>这种继承关系比较特殊，父类只有 typedef</p>
<p>G4.9 用继承关系继承了五个 typedef，只是为了把 typedef 继承下去而已，少写一部分代码</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230729180517956.png" alt="image-20230729180517956"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230729181031248.png" alt="image-20230729181031248"></p>
<h3 id="迭代器分类对算法的影响"><a href="#迭代器分类对算法的影响" class="headerlink" title="迭代器分类对算法的影响"></a>迭代器分类对算法的影响</h3><h4 id="distance"><a href="#distance" class="headerlink" title="distance()"></a>distance()</h4><p>对于不同类型的迭代器  distance() 这个函数的实现会不一样</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230729181630375.png" alt="image-20230729181630375"></p>
<p>有两种实现方式</p>
<p>如果是 连续内存，直接减</p>
<p>如果不是连续内存，就要一步步加，比较</p>
<p>返回值要用迭代器的 difference_type 不能随便用整数存</p>
<p>这里利用 traits 获取类型</p>
<p>用类型加()，实例化一个对象，便于函数传递参数类型，决定函数调用哪个</p>
<h4 id="advance"><a href="#advance" class="headerlink" title="advance()"></a>advance()</h4><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230809203604180.png" alt="image-20230809203604180"></p>
<p>前进某个距离</p>
<p>​     是一步步走  还是直接跳过去</p>
<p>这里换了一个写法，实现了一个函数，通过 traits 获取类型实例化对象。</p>
<p>利用不同类型的对象做分支，好处可以利用继承关系， is-a。即使没有对应类型的实现，也会做相应的转型。</p>
<h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230809204853613.png" alt="image-20230809204853613"></p>
<p>copy 先检查迭代器类型</p>
<p>如果是 const char*   const wchar_t* 直接 memmove() 速度很快</p>
<p>其它分支</p>
<p>​    如果是 randomAccessIterator  计算个数 last-first 相比 first!&#x3D;last 要快</p>
<p>​    如果是  inputIterator      需要 first!&#x3D;last 条件比较，一个个拷贝构造</p>
<p>如果是指针，看是否有不重要的拷贝赋值操作  has trivial op&#x3D;() ，不重要就 memmove   例如复数类 因为这样的类不需要写拷贝赋值 拷贝构造 析构函数</p>
<p>​       重要就  last -first 一个个拷贝</p>
<h4 id="destory"><a href="#destory" class="headerlink" title="destory"></a>destory</h4><p>destory 也会判断有没有重要的析构函数</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230810193758187.png" alt="image-20230810193758187"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230810193826962.png" alt="image-20230810193826962"></p>
<h4 id="unique-copy"><a href="#unique-copy" class="headerlink" title="unique_copy"></a>unique_copy</h4><p>独一无二的 copy  重复的元素不拷贝</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230810194035071.png" alt="image-20230810194035071"></p>
<p>如果传进来的是 output iterator 跑到 forward iterator 版本，这样不可以。</p>
<p>所以又写了一个  output iterator 版本</p>
<p>算法源码对迭代器的类型没有强制的要求，会有些“暗示”</p>
<p>sort 其实是快排，里边会跳跃读取数据，所以需要是 random iterator</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230810195535783.png" alt="image-20230810195535783"></p>
<h3 id="算法示例"><a href="#算法示例" class="headerlink" title="算法示例"></a>算法示例</h3><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230810200221351.png" alt="image-20230810200221351"></p>
<h4 id="算法-accumulate"><a href="#算法-accumulate" class="headerlink" title="算法 accumulate"></a>算法 accumulate</h4><p>累计</p>
<p>算法有两个版本</p>
<p>第一个版本   将初值累加到一个元素</p>
<p>第二个版本   可以传入 op ，自定义运算</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230812194510444.png" alt="image-20230812194510444"></p>
<p>binary_op 是一个仿函数 传入的参数只要能使用 () 调用就可以  function object</p>
<h4 id="算法-for-each"><a href="#算法-for-each" class="headerlink" title="算法 for_each"></a>算法 for_each</h4><p>对每个元素做指定的操作</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230812200309943.png" alt="image-20230812200309943"></p>
<h4 id="算法-replace-replace-if-replace-copy"><a href="#算法-replace-replace-if-replace-copy" class="headerlink" title="算法 replace, replace_if, replace_copy"></a>算法 replace, replace_if, replace_copy</h4><p>取代 </p>
<p>replace_if  要传递一个条件</p>
<p>replace_copy  不会取代，会拷贝到新的地方去</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230812201008512.png" alt="image-20230812201008512"></p>
<h4 id="算法-count-count-if"><a href="#算法-count-count-if" class="headerlink" title="算法 count, count_if"></a>算法 count, count_if</h4><p>计量</p>
<p>有些算法容器会自带 count 函数，针对自己的容器做了优化</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230812201441966.png" alt="image-20230812201441966"></p>
<h4 id="算法-find-find-if"><a href="#算法-find-find-if" class="headerlink" title="算法 find, find_if"></a>算法 find, find_if</h4><p>找元素   一个个查找</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230812203355789.png" alt="image-20230812203355789"></p>
<h4 id="算法-sort"><a href="#算法-sort" class="headerlink" title="算法 sort"></a>算法 sort</h4><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230812203327459.png" alt="image-20230812203327459"></p>
<p>rbegin() rend() 逆向</p>
<p>关联式容器不带 sort</p>
<h4 id="关于-reverse-iterator-rbeign-rend"><a href="#关于-reverse-iterator-rbeign-rend" class="headerlink" title="关于 reverse iterator, rbeign(),rend()"></a>关于 reverse iterator, rbeign(),rend()</h4><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230813153928015.png" alt="image-20230813153928015"></p>
<p>rbegin() 其实就是 end()  返回值需要一个适配器包起来</p>
<h4 id="binary-search"><a href="#binary-search" class="headerlink" title="binary search"></a>binary search</h4><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230813154246025.png" alt="image-20230813154246025"></p>
<p>调用 lower_bound   uper_bound</p>
<h3 id="仿函数-functors"><a href="#仿函数-functors" class="headerlink" title="仿函数 functors"></a>仿函数 functors</h3><p>最容易 比较可能自定义来融入 STL 的东西</p>
<p>算法使用，operator</p>
<p>要实现 () 运算符</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230813213707788.png" alt="image-20230813213707788"></p>
<p>GNU C++ 独有的 仿函数</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230813214215660.png" alt="image-20230813214215660"></p>
<p>GNU 4.9 改名字了  兼容性不好</p>
<p>几种仿函数的形式</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230813214619164.png" alt="image-20230813214619164"></p>
<p>标准库的仿函数都继承了  binary_function&lt;T,T,bool&gt;   binary 代表了两个操作数的函数</p>
<p>为什么这么做，便于继承 typedef  用于adapter 提问类型</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230813215244076.png" alt="image-20230813215244076"></p>
<h3 id="适配器-Adapters"><a href="#适配器-Adapters" class="headerlink" title="适配器 Adapters"></a>适配器 Adapters</h3><p>小改造   把现有的东西函数名改一下  参数个数改一下</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230813220502935.png" alt="image-20230813220502935"></p>
<p>内含而不是继承 来实现 Adapters</p>
<h4 id="容器适配器：stack-queue"><a href="#容器适配器：stack-queue" class="headerlink" title="容器适配器：stack queue"></a>容器适配器：stack queue</h4><p>stack 内含了一个 queue 只开放了部分函数出来，而且改名了</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230813221211204.png" alt="image-20230813221211204"></p>
<h4 id="函数适配器-binder2nd"><a href="#函数适配器-binder2nd" class="headerlink" title="函数适配器 binder2nd"></a>函数适配器 binder2nd</h4><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230815201809620.png" alt="image-20230815201809620"></p>
<p>bind2nd  将 less 函数的第二个参数设置为 40</p>
<p>函数在没调用的时候，就设置了第二个参数</p>
<p>适配器适配谁，就要把原来的东西记起来</p>
<p>less 会被记录到 op 变量里边，40 会被记录到 value</p>
<p>适配器适配什么东西，就要做成什么样子。现在是在修饰一个 functor 就要实现 operator()</p>
<p>因为 Operation 这个类型不好编写，所以做了一个辅助函数 bind2nd 然后使用 Op 来推出类型，方便声明成员变量然后调用。</p>
<p>这个示例中 less<int> 需要第二参数是是 int 类型，所以在传入第二参数的时候，最好是可以帮忙做类型检查。通过 Operation::second_argument_type 去询问该参数第二参数的类型是什么，然后用该类型做转换。如果转换不过，就会报错。</p>
<p>所以 Operation 中需要有定义去回答关于类型的问题。</p>
<p>在返回值的部分，返回值也应该是被修饰者的返回的类型</p>
<p>传入的第一个实参部分，也是通过 Operation::first_argument_type 去获取。</p>
<p>需要 functor 能回答这些问题，如果可以回答，那么这些 functor 可以称为可适配的。</p>
<p>在上文中如果 less 继承了 binary_function 就可以回答这些问题了</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230815210124354.png" alt="image-20230815210124354"></p>
<p>关于 typename </p>
<p>辅助编译器说明 Operation，帮助编译</p>
<p>binder2nd 也要继承 unary_function 为了回答相应的问题，unary_function 指的是单一参数</p>
<h4 id="新型适配器-bind"><a href="#新型适配器-bind" class="headerlink" title="新型适配器 bind"></a>新型适配器 bind</h4><p>右边的已经过时了，bind 很复杂</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230815213626345.png" alt="image-20230815213626345"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230816203759517.png" alt="image-20230816203759517"></p>
<p>bind 可以绑定 class 里边的成员函数和数据成员，_1 其实是占位符</p>
<p>bind<int> 绑定返回类型</p>
<h4 id="函数适配器-not1"><a href="#函数适配器-not1" class="headerlink" title="函数适配器 not1"></a>函数适配器 not1</h4><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230816204205063.png" alt="image-20230816204205063"></p>
<h4 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h4><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230816210951499.png" alt="image-20230816210951499">注意 operator*() 的取值是在逆向迭代器退一格 </p>
<h4 id="迭代器适配器-inserter"><a href="#迭代器适配器-inserter" class="headerlink" title="迭代器适配器 inserter"></a>迭代器适配器 inserter</h4><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230816210957987.png" alt="image-20230816210957987">copy 是赋值操作，不管目标地址空间是否合理</p>
<p>copy 的目标地址如果不是 inserter 迭代器，覆盖掉后边的值。</p>
<p>利用操作符重载将 Copy 中的赋值操作改变掉，使用容器的 insert 函数</p>
<h4 id="X-适配器-ostream-iterator-未知适配器"><a href="#X-适配器-ostream-iterator-未知适配器" class="headerlink" title="X 适配器: ostream_iterator  未知适配器"></a>X 适配器: ostream_iterator  未知适配器</h4><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230816211005014.png" alt="image-20230816211005014"></p>
<p>通过改变赋值操作符，结合 copy 函数，向字符串中插入 “,”    ++操作符失效</p>
<h4 id="X-适配器-istream-iterator"><a href="#X-适配器-istream-iterator" class="headerlink" title="X 适配器: istream_iterator"></a>X 适配器: istream_iterator</h4><p>需要连接的是 cin</p>
<p>eos 代表一个结束的标志</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230828201208327.png" alt="image-20230828201208327"></p>
<p>绑定 input ，刚开始创建对象的时候 立马 ++，读取数据</p>
<p>希望 copy  从 cin 读数据，然后放到目的端</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230828202341781.png" alt="image-20230828202341781"></p>
<h2 id="万用-hash-function"><a href="#万用-hash-function" class="headerlink" title="万用 hash function"></a>万用 hash function</h2><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230906203848509.png" alt="image-20230906203848509"></p>
<p>字符数字其实就可以当作 hashcode</p>
<p>上边是两种实现 hashfunc 的方式</p>
<p>左边是一个像函数的对象，右边是一个函数，左边方便一点不用写复杂的类型。</p>
<p>一个对象的 hashcode  一种方法是把这个对象所有基础元素的 hashcode 加起来就是这个对象的 hashcode，想法可能比较天真，code 冲突可能会比较多。</p>
<p>tr1 版本中，首先看下边的三个函数 1，2，3 参数不同。</p>
<p>借助于 C++ 的语法  typename…  </p>
<p>​     流程是先把 seed combine 然后调自己，再次 combine 变化 seed</p>
<p>​    举个例子：参数个数刚开始是 5  之后函数调用参数变为 1+4  1+3  1+2 ，不断取第一个参数变化 seed 最后的 seed 就是 hashcode</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230906203909937.png" alt="image-20230906203909937"></p>
<p>这种思想的来源可能来自于黄金比例</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230906204625697.png" alt="image-20230906204625697"></p>
<p>tr1的代码</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230906204645119.png" alt="image-20230906204645119"></p>
<p>hashfunction 指定及调用</p>
<p>默认的篮子个数变了 变成了 11</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230906205013669.png" alt="image-20230906205013669"></p>
<p>如果没有该类型的 hashfunc  可以自己写偏特化版本</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230906205123247.png" alt="image-20230906205123247"></p>
<p>旧版本标准库没有对 string 写偏特化版本 hash</p>
<p>对 MyString 实现 hashfunc</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230906205644144.png" alt="image-20230906205644144"></p>
<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>一堆东西的组合</p>
<p>指定任意个数的元素，任意的类型</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230914213542645.png" alt="image-20230914213542645"></p>
<p>tie(i1,f1,s1) &#x3D; t3  将 t3 的成分拿出来</p>
<p>其中 sizeof(t) 为什么是 32 不是 28   不清楚</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230914214525087.png" alt="image-20230914214525087"></p>
<p>这种实现有一个主体，还有一个结束条件。</p>
<p>… 自动递归层层继承。</p>
<h2 id="type-traits"><a href="#type-traits" class="headerlink" title="type traits"></a>type traits</h2><p>has_trivail   有不重要的 xxx 吗？  __false_type   没有</p>
<p>所以意思就是重要</p>
<p>如果不是这种默认的答案，可以自己写一个偏特化的例子。</p>
<p>标准库实现了一些基础类型的特化版本。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916090826613.png" alt="image-20230916090826613"></p>
<p>C++ 2.0 type traits 变多</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916090847529.png" alt="image-20230916090847529"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916091151682.png" alt="image-20230916091151682"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916091423619.png" alt="image-20230916091423619"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916091453065.png" alt="image-20230916091453065"></p>
<p>string 内部有指针，所以有重要的析构函数。</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916092448488.png" alt="image-20230916092448488"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916092455357.png" alt="image-20230916092455357"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916092501924.png" alt="image-20230916092501924"></p>
<p>对应的就是   is_copy_constructible    is_move_constructible    is_copy_assignable   is_move_assginable</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916093623966.png" alt="image-20230916093623966"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916093634792.png" alt="image-20230916093634792"></p>
<h3 id="type-traits-实现"><a href="#type-traits-实现" class="headerlink" title="type traits 实现"></a>type traits 实现</h3><h4 id="实现-is-void"><a href="#实现-is-void" class="headerlink" title="实现 is_void"></a>实现 is_void</h4><p>remove_cv  指的是去掉 const 和 volatile</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916093644704.png" alt="image-20230916093644704"></p>
<p>以 remove const 为例</p>
<p>会有两个版本</p>
<p>一个是泛化的版本  一个是特化的版本</p>
<p>如果是 const 的类型 就会经过特化版本将 const 移除掉</p>
<p>在 remove const volatile 移除掉之后</p>
<p>有两个版本，如果是 void 会进入 void 的版本，实现了 void 的判断</p>
<h4 id="实现-is-integral"><a href="#实现-is-integral" class="headerlink" title="实现 is_integral"></a>实现 is_integral</h4><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916173209871.png" alt="image-20230916173209871"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916173823329.png" alt="image-20230916173823329"></p>
<p>没有找到源代码，可能是编译器处理的</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916174121739.png" alt="image-20230916174121739"></p>
<h3 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h3><p>cout 有很多基本类型的运算符重载</p>
<p>cout 是一个对象</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916174540684.png" alt="image-20230916174540684"></p>
<p>标准库里边实现的操作符重载</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230916174841180.png" alt="image-20230916174841180"></p>
<h2 id="movable-元素对性能的影响"><a href="#movable-元素对性能的影响" class="headerlink" title="movable 元素对性能的影响"></a>movable 元素对性能的影响</h2><p>容器里边的元素有没有 movable 功能有巨大影响</p>
<p>CCtor 拷贝构造</p>
<p>MCtor  移动构造</p>
<p>vertor 因为有一个2倍增长的逻辑，所以会调用 2倍 size 的构造函数</p>
<p>只有 vector 是连续内存，所以 construction 速度差别巨大，而带节点的容器差别不大</p>
<p>movable 版本对其它操作也有性能的好处</p>
<h3 id="movable-对各种容器的性能测试"><a href="#movable-对各种容器的性能测试" class="headerlink" title="movable 对各种容器的性能测试"></a>movable 对各种容器的性能测试</h3><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917093700847.png" alt="image-20230917093700847"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917093708546.png" alt="image-20230917093708546"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917093715366.png" alt="image-20230917093715366"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917093722334.png" alt="image-20230917093722334"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917093729426.png" alt="image-20230917093729426"></p>
<h3 id="写一个-movable-class"><a href="#写一个-movable-class" class="headerlink" title="写一个 movable class"></a>写一个 movable class</h3><p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917093757490.png" alt="image-20230917093757490"></p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917093803249.png" alt="image-20230917093803249"></p>
<h3 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h3><p>move 之后确保原来的东西不会使用</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917094843213.png" alt="image-20230917094843213"></p>
<p>insert 的时候，确保 buf 不会再使用，所以会用 move 版本 insert</p>
<p>深拷贝</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917100225231.png" alt="image-20230917100225231"></p>
<p>浅拷贝  move ctor 只是 swap 了几个容器的指针 </p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917100310510.png" alt="image-20230917100310510"></p>
<p>std::string 有moveable 的实现</p>
<p><img src="https://github.com/imlihang/BlogImage/raw/master/2022/hou_cpp/image-20230917100925551.png" alt="image-20230917100925551"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C</a>
              <a href="/tags/%E4%BE%AF%E6%8D%B7/" rel="tag"># 侯捷</a>
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/12/14/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" rel="prev" title="C++程序设计">
      <i class="fa fa-chevron-left"></i> C++程序设计
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/11/TVM%E9%85%8D%E7%BD%AE/" rel="next" title="TVM调试配置">
      TVM调试配置 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-Standard-Library-vs-Standard-Template-Library"><span class="nav-number">1.</span> <span class="nav-text">C++ Standard Library vs. Standard Template Library</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL-%E5%85%AD%E5%A4%A7%E9%83%A8%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">STL 六大部件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6-Complexity-Big-oh"><span class="nav-number">3.</span> <span class="nav-text">复杂度 Complexity, Big-oh</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E9%97%AD%E5%90%8E%E5%BC%80-%E5%8C%BA%E9%97%B4"><span class="nav-number">4.</span> <span class="nav-text">前闭后开 区间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-%E2%80%94-%E7%BB%93%E6%9E%84%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text">容器 — 结构与分类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Set-%E4%B8%8E-Map-%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.</span> <span class="nav-text">Set 与 Map 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-array"><span class="nav-number">5.2.</span> <span class="nav-text">使用容器 array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8vector"><span class="nav-number">5.3.</span> <span class="nav-text">使用vector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-list"><span class="nav-number">5.4.</span> <span class="nav-text">使用 list</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-forward-list"><span class="nav-number">5.5.</span> <span class="nav-text">使用 forward_list</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-slist"><span class="nav-number">5.6.</span> <span class="nav-text">使用 slist</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-deque"><span class="nav-number">5.7.</span> <span class="nav-text">使用 deque</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-stack"><span class="nav-number">5.8.</span> <span class="nav-text">使用 stack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8queue"><span class="nav-number">5.9.</span> <span class="nav-text">使用queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8multiset"><span class="nav-number">5.10.</span> <span class="nav-text">使用multiset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-multimap"><span class="nav-number">5.11.</span> <span class="nav-text">使用容器 multimap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-unordered-multiset"><span class="nav-number">5.12.</span> <span class="nav-text">使用容器 unordered_multiset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-unordered-multiset-1"><span class="nav-number">5.13.</span> <span class="nav-text">使用容器 unordered_multiset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-set"><span class="nav-number">5.14.</span> <span class="nav-text">使用容器 set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-map"><span class="nav-number">5.15.</span> <span class="nav-text">使用容器 map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.15.0.1.</span> <span class="nav-text"></span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-unordered-set"><span class="nav-number">5.16.</span> <span class="nav-text">使用容器 unordered_set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8-unordered-map"><span class="nav-number">5.17.</span> <span class="nav-text">使用容器 unordered_map</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">6.</span> <span class="nav-text">使用分配器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%89%88%E6%9C%AC"><span class="nav-number">7.</span> <span class="nav-text">标准库版本</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#OOP-vs-GP"><span class="nav-number">8.</span> <span class="nav-text">OOP vs. GP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD-Operator-Overloading"><span class="nav-number">9.</span> <span class="nav-text">操作符重载 Operator Overloading</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF"><span class="nav-number">10.</span> <span class="nav-text">模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Class-Templates-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">10.1.</span> <span class="nav-text">Class Templates 类模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Function-Templates-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">10.2.</span> <span class="nav-text">Function Templates 函数模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Member-Templates-%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF"><span class="nav-number">10.3.</span> <span class="nav-text">Member Templates,成员模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Specialization-%E7%89%B9%E5%8C%96"><span class="nav-number">10.4.</span> <span class="nav-text">Specialization 特化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Partial-Specialization-%E5%81%8F%E7%89%B9%E5%8C%96"><span class="nav-number">10.5.</span> <span class="nav-text">Partial Specialization 偏特化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%99%A8-allocators"><span class="nav-number">11.</span> <span class="nav-text">分配器 allocators</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-number">12.</span> <span class="nav-text">容器结构与分类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2list"><span class="nav-number">13.</span> <span class="nav-text">深度探索list</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-iterator"><span class="nav-number">14.</span> <span class="nav-text">迭代器的设计原则 iterator</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-vector"><span class="nav-number">15.</span> <span class="nav-text">容器 vector</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#vector-iterator"><span class="nav-number">15.1.</span> <span class="nav-text">vector iterator</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-array"><span class="nav-number">16.</span> <span class="nav-text">容器 array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-forward-list"><span class="nav-number">17.</span> <span class="nav-text">容器 forward_list</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-deque"><span class="nav-number">18.</span> <span class="nav-text">容器 deque</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#insert"><span class="nav-number">18.1.</span> <span class="nav-text">insert()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deque%E6%A8%A1%E6%8B%9F%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4"><span class="nav-number">18.2.</span> <span class="nav-text">deque模拟连续空间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-rb-tree"><span class="nav-number">19.</span> <span class="nav-text">容器 rb_tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-set-multiset"><span class="nav-number">20.</span> <span class="nav-text">容器 set,multiset</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-map-multimap"><span class="nav-number">21.</span> <span class="nav-text">容器 map,multimap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-hashtable"><span class="nav-number">22.</span> <span class="nav-text">容器 hashtable</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">23.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">23.1.</span> <span class="nav-text">算法是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">23.2.</span> <span class="nav-text">迭代器的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB%E5%AF%B9%E7%AE%97%E6%B3%95%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">23.2.1.</span> <span class="nav-text">迭代器分类对算法的影响</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#distance"><span class="nav-number">23.2.1.1.</span> <span class="nav-text">distance()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#advance"><span class="nav-number">23.2.1.2.</span> <span class="nav-text">advance()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy"><span class="nav-number">23.2.1.3.</span> <span class="nav-text">copy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#destory"><span class="nav-number">23.2.1.4.</span> <span class="nav-text">destory</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unique-copy"><span class="nav-number">23.2.1.5.</span> <span class="nav-text">unique_copy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-number">23.2.2.</span> <span class="nav-text">算法示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95-accumulate"><span class="nav-number">23.2.2.1.</span> <span class="nav-text">算法 accumulate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95-for-each"><span class="nav-number">23.2.2.2.</span> <span class="nav-text">算法 for_each</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95-replace-replace-if-replace-copy"><span class="nav-number">23.2.2.3.</span> <span class="nav-text">算法 replace, replace_if, replace_copy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95-count-count-if"><span class="nav-number">23.2.2.4.</span> <span class="nav-text">算法 count, count_if</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95-find-find-if"><span class="nav-number">23.2.2.5.</span> <span class="nav-text">算法 find, find_if</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95-sort"><span class="nav-number">23.2.2.6.</span> <span class="nav-text">算法 sort</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-reverse-iterator-rbeign-rend"><span class="nav-number">23.2.2.7.</span> <span class="nav-text">关于 reverse iterator, rbeign(),rend()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#binary-search"><span class="nav-number">23.2.2.8.</span> <span class="nav-text">binary search</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0-functors"><span class="nav-number">23.2.3.</span> <span class="nav-text">仿函数 functors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8-Adapters"><span class="nav-number">23.2.4.</span> <span class="nav-text">适配器 Adapters</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%9Astack-queue"><span class="nav-number">23.2.4.1.</span> <span class="nav-text">容器适配器：stack queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8-binder2nd"><span class="nav-number">23.2.4.2.</span> <span class="nav-text">函数适配器 binder2nd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8-bind"><span class="nav-number">23.2.4.3.</span> <span class="nav-text">新型适配器 bind</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8-not1"><span class="nav-number">23.2.4.4.</span> <span class="nav-text">函数适配器 not1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">23.2.4.5.</span> <span class="nav-text">迭代器适配器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8-inserter"><span class="nav-number">23.2.4.6.</span> <span class="nav-text">迭代器适配器 inserter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#X-%E9%80%82%E9%85%8D%E5%99%A8-ostream-iterator-%E6%9C%AA%E7%9F%A5%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">23.2.4.7.</span> <span class="nav-text">X 适配器: ostream_iterator  未知适配器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#X-%E9%80%82%E9%85%8D%E5%99%A8-istream-iterator"><span class="nav-number">23.2.4.8.</span> <span class="nav-text">X 适配器: istream_iterator</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%87%E7%94%A8-hash-function"><span class="nav-number">23.3.</span> <span class="nav-text">万用 hash function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tuple"><span class="nav-number">23.4.</span> <span class="nav-text">tuple</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-traits"><span class="nav-number">23.5.</span> <span class="nav-text">type traits</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#type-traits-%E5%AE%9E%E7%8E%B0"><span class="nav-number">23.5.1.</span> <span class="nav-text">type traits 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-is-void"><span class="nav-number">23.5.1.1.</span> <span class="nav-text">实现 is_void</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-is-integral"><span class="nav-number">23.5.1.2.</span> <span class="nav-text">实现 is_integral</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cout"><span class="nav-number">23.5.2.</span> <span class="nav-text">cout</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#movable-%E5%85%83%E7%B4%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">23.6.</span> <span class="nav-text">movable 元素对性能的影响</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#movable-%E5%AF%B9%E5%90%84%E7%A7%8D%E5%AE%B9%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="nav-number">23.6.1.</span> <span class="nav-text">movable 对各种容器的性能测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA-movable-class"><span class="nav-number">23.6.2.</span> <span class="nav-text">写一个 movable class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0"><span class="nav-number">23.6.3.</span> <span class="nav-text">测试函数</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Henry</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/imlihang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;imlihang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:363461885@qq.com" title="E-Mail → mailto:363461885@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Henry</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
